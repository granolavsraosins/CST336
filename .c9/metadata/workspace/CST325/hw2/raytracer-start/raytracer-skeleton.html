{"changed":false,"filter":false,"title":"raytracer-skeleton.html","tooltip":"/CST325/hw2/raytracer-start/raytracer-skeleton.html","value":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"utf-8\">\n\t<title>Raytracer</title>\n</head>\n<body>\n<canvas id='my-canvas'><canvas>\n\n<script src='vector3.js'></script>\n<script src='ray.js'></script>\n<script src='sphere.js'></script>\n<script src='plane.js'></script>\n<script>\n\n// Canvas setup, don't need to touch any of this *******************************\n// Get a reference to the javascript object associated with the canvas\nvar canvas = document.getElementById('my-canvas');\n\n// The canvas dimension we will set\nvar pixelsAcross = 256;  // pixels across\nvar pixelsDown = 256; // pixels down\n\n// Set dimensions and pixel scale (don't worry about pixel scale, it won't affect your maths)\nvar pixelScale = 3;\ncanvas.width = pixelsAcross;\ncanvas.height = pixelsDown;\ncanvas.style.cssText = 'width:' + (pixelsAcross * pixelScale) + 'px;height:' + (pixelsDown * pixelScale) + 'px';\n\n// Get the context from the canvas (in this case we just want 2d)\nvar canvasContext = canvas.getContext('2d');\n\n// Get an array representing all of the pixels\n// Arranged left to right, top to bottom\nvar imageData = canvasContext.getImageData(0, 0, pixelsAcross, pixelsDown);\n// end canvas setup ************************************************************\n\n\n// Raytracer setup\nvar fov = 45;   // if this changes, your code should still work\nvar fovRadians = fov * (Math.PI / 180); // todo -> convert degrees to radians\n\nvar pixelWidth = 2 / pixelsAcross; // todo -> what's the size of a pixel from left to right?\nvar pixelHalfWidth = pixelWidth / 2; // todo -> half of the pixel width\n\n// How far away (scalar) the eye is from the image plane (see MV3202 guide for more info)\nvar eyeDistance = 1 / Math.tan(fov / 2); // = todo -> hint: related to tangent and field of view (see slides)\n// -----------\n// |         /\n// |        /\n// |       /\n// | 45/2 /      <---- half angle\n// |     /\n// |    /\n// |   /\n// |  /\n// | /\n\n// important vectors\nvar eyeCoordinate = new Vector3(0, 0, eyeDistance); // all of your rays will use this\n\n// these can be convenient (up to you whether you want to use them)\nvar right = new Vector3(1, 0, 0);\nvar up = new Vector3(0, 1, 0);\n\n// Define the scene objects here ------------------\n\n// These are 3d definitions that match all of the math we did in class\n// They also provide a \"raycast\" function that you can pass a ray to\n// in order to find intersection between the ray and the object\n\nvar sphere = new Sphere(new Vector3(0,0,0), 0.2); // todo = new Sphere(..., ...);\nvar plane = new Plane(new Vector3(0,1,0),new Vector3(0,-0.2,0)); // todo = new Plane(..., ...);\n\n// end of raytracer setup ******************************************************\n\n// -----------------------------------------------------------------------------\n// return a ray that goes from the eye point through the pixel at index (xPixelIndex, yPixelIndex)\nfunction generateRayForPixel(xPixelIndex, yPixelIndex) {\n\n\t//var pixelCoordinate = ((xPixelIndex * pixelWidth) - 1) + pixelHalfWidth // todo: calculate pixel position\n\tvar direction = new Vector3(((xPixelIndex * pixelWidth) - 1) + pixelHalfWidth,(1 - (yPixelIndex * pixelWidth)) + pixelHalfWidth,-eyeDistance); // = vector from the eye to the pixel\n\n\t// Creates a ray that will automatically normalize the direction\n\t// Uncomment this (the ray line of code) once you've calculated the pixelCoordinate in space and the\n\t// direction from the eye to the pixelCoordinate\n\tvar pixelRay = new Ray(eyeCoordinate, direction);\n\treturn pixelRay;\n}\n\n// -----------------------------------------------------------------------------\nfunction setPixelColor(xPixelIndex, yPixelIndex, shadeOfGray /*[0,1]*/) {\n\tvar index = (xPixelIndex + (yPixelIndex * pixelsAcross)) * 4;\n\n\timageData.data[index + 0] = shadeOfGray * 255;\n\timageData.data[index + 1] = shadeOfGray * 255;\n\timageData.data[index + 2] = shadeOfGray * 255;\n\timageData.data[index + 3] = 255;\n\n\t// feel free to delete this when you are done implementing this function\n\tif (index == undefined) {\n\t\talert('need to calculate the image data index for setting pixel color');\n\t\tthrow 'error';\n\t}\n}\n\n// -----------------------------------------------------------------------------\nfunction updateAndRender(timeElapsed) {\n\tvar seconds = timeElapsed * 0.001;\n\tvar lightPos =  new Vector3(1,0,0);\n\t// Go through every pixel\n\tfor (var yPixelIndex = 0; yPixelIndex < pixelsDown; ++yPixelIndex) {\n\n\t\tfor (var xPixelIndex = 0; xPixelIndex < pixelsAcross; ++xPixelIndex) {\n\n\t\t\t//Uncomment this once you've coded generateRayForPixel\n\t\t\tvar pixelRay = generateRayForPixel(xPixelIndex, yPixelIndex);\n\t\t\t//var maxValue = Math.sin(Math.sqrt(2) / 4);\n\t\t\t\n\t\t\t//setPixelColor(xPixelIndex, yPixelIndex, Math.abs(pixelRay.direction.x) / maxValue);\n\t\t\t// See if the ray intersects the sphere or the plane (or every object in our scene)\n\t\t\t// Uncomment when your sphere or plane code is ready\n\t\t\tvar sphereResult = sphere.raycast(pixelRay);\n\t\t\tvar planeResult = plane.raycast(pixelRay);\n\n\t\t\tvar hitSphere = (sphereResult.hit);// || planeResult.hit);\n\t\t\tvar hitPlane = planeResult.hit;\n\t\t\t\n\t\t\t// determine  which hit object is the closest (in case there is more than 1 hit)\n\t\t\tif (hitSphere && hitPlane) {\n\t\t\t\tif(sphereResult.distance < planeResult.distance) {\n\t\t\t\t\tvar normalDotLight = (sphereResult.normal).dot(lightPos);\n\t\t\t\t\tsetPixelColor(xPixelIndex, yPixelIndex, normalDotLight); \n\t\t\t\t} else {\n\t\t\t\t\tvar normalDotLight = (planeResult).dot(lightPos);\n\t\t\t\t\tsetPixelColor(xPixelIndex, yPixelIndex, normalDotLight);\n\t\t\t\t}\n\t\t\t} else if (hitSphere) {\n\t\t\t\tvar normalDotLight = (sphereResult.normal).dot(lightPos);\n\t\t\t\tsetPixelColor(xPixelIndex, yPixelIndex, normalDotLight); \n\t\t\t} else if(hitPlane) {\n\t\t\t\tvar normalDotLight = (planeResult.normal).dot(lightPos);\n\t\t\t\tsetPixelColor(xPixelIndex, yPixelIndex, normalDotLight);\n\t\t\t} else {\n\t\t\t\t// we didn't hit anything, choose an appropriate backbround color\n\t\t\t\tsetPixelColor(xPixelIndex, yPixelIndex, 0.1); // dark gray\n\t\t\t}\n\t\t}\n\t}\n\n\t// Take our array of color data and give to the canvas to display\n\tcanvasContext.putImageData(imageData, 0, 0);\n\n\t// Let the browser know it should call this function again when it's time to render\n\trequestAnimationFrame(updateAndRender);\n}\n\n// We are ready to render, let the browser know\nrequestAnimationFrame(updateAndRender);\n\n</script>\n</body>\n</html>","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":1200,"scrollleft":0,"selection":{"start":{"row":121,"column":55},"end":{"row":121,"column":55},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":84,"state":"js-start","mode":"ace/mode/html"}},"timestamp":1541704010896}